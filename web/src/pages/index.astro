---

---

<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Admapu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">


  <link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
  integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>

  <style>
    :root {
      --font-title: "Space Grotesk", system-ui, sans-serif;
      --font-body: "IBM Plex Sans", system-ui, sans-serif;
    
      --neon-pink: #ff2bd6;
      --neon-cyan: #19f5ff;
      --neon-purple: #7a5cff;
      --bg-dark: #05010a;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      font-family: var(--font-body);
      background: var(--bg-dark);
      color: white;
      overflow: hidden;
    }

    /* ===== Background image ===== */
    .scene {
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(
          rgba(10, 1, 40, 0.35),
          rgba(10, 1, 40, 0.55)
        ),
        url("assets/_bg-real.png");
      background-size: cover;
      background-position: center;
      filter: saturate(1.2) contrast(1.15);
      z-index: 0;
    }

    /* ===== Canvas for animated nodes ===== */
    canvas {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }

    /* ===== Centered content ===== */
    .content {
      position: relative;
      z-index: 2;
      height: 100%;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1.5rem;
    }

    .inner {
      margin-top: -3rem;
      max-width: 820px;
    }

    h1 {
  font-family: var(--font-title);
  font-size: clamp(3.2rem, 9vw, 5.6rem);
  font-weight: 700;
  letter-spacing: -0.04em;
  margin-bottom: 1rem;

  color: var(--neon-pink);
  text-shadow:
    0 0 12px rgba(255, 43, 214, 0.8),
    0 0 36px rgba(255, 43, 214, 0.6);
}

    p {
      font-size: clamp(1rem, 2.4vw, 1.25rem);
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 12px rgba(25, 245, 255, 0.25);
    }

    /* ===== Subtle glow vignette ===== */
    .vignette {
      position: fixed;
      inset: 0;
      box-shadow:
        inset 0 0 120px rgba(0, 0, 0, 0.9);
      z-index: 3;
      pointer-events: none;
    }

.subtitle {
  font-family: var(--font-body);
  font-size: clamp(1.05rem, 2.6vw, 1.3rem);
  line-height: 1.7;
  font-weight: 400;
  letter-spacing: 0.01em;
  color: rgba(255, 255, 255, 0.88);
  max-width: 880px;
  margin: 0 auto 1.3rem;
}

.github-link {
  display: inline-flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 0.95rem;
  color: var(--neon-cyan);
  text-decoration: none;
  opacity: 0.85;
  transition: opacity 0.2s ease, text-shadow 0.2s ease;
}

.github-link i {
  font-size: 1.15rem;
}

.github-link:hover {
  opacity: 1;
  text-shadow:
    0 0 8px rgba(25, 245, 255, 0.6),
    0 0 16px rgba(122, 92, 255, 0.4);
}
  </style>
</head>
<body>

  <!-- Background -->
  <div class="scene"></div>

  <!-- Animated network -->
  <canvas id="network"></canvas>

  <!-- Text -->
  <div class="content">
    <div class="inner">
      <h1>Admapu</h1>
      <p>
        PoC de una stablecoin ERC-20 dise√±ada para ser utilizada exclusivamente por ciudadanos chilenos,
        donde la elegibilidad se demuestra on-chain mediante un verificador de identidad externo basado
        en Zero-Knowledge.
      </p>

      <p>
      <a
        class="github-link"
        href="https://github.com/boris/admapu"
        target="_blank"
        rel="noopener noreferrer"
      >
        <i class="fa-brands fa-github"></i>
      </a>
      </p>
    </div>
  </div>

  <div class="vignette"></div>

  <!-- ===== JS: animated nodes ===== -->
<script>
  const canvas = document.getElementById("network");
  const ctx = canvas.getContext("2d");

  let width, height, dpr;

  // Pointer (mouse / touch)
  const pointer = {
    x: 0,
    y: 0,
    active: false,   // true while mouse over / touch down
    radius: 170      // influence radius
  };

  // Tuning
  const MAX_DIST = 140;              // connection distance
  const BASE_SPEED = 0.45;           // base velocity cap
  const FRICTION = 0.985;            // velocity damping
  const RETURN_FORCE = 0.0025;       // gentle pull to original position
  const POINTER_FORCE = 0.055;       // attraction/repulsion strength
  const POINTER_MIN_DIST = 18;       // avoid exploding near cursor
  const HOVER_BOOST = 1.35;          // brightness/opacity boost near pointer

  // Neon colors (Tokyo-ish)
  const COLOR_NODE = { r: 25, g: 245, b: 255 };      // cyan
  const COLOR_LINE = { r: 122, g: 92, b: 255 };      // purple

  // Nodes
  let nodes = [];
  let NODE_COUNT = 0;

  function setCanvasSize() {
    dpr = Math.min(2, window.devicePixelRatio || 1);
    width = canvas.width = Math.floor(window.innerWidth * dpr);
    height = canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function buildNodes() {
    // Density scales with viewport; keep it reasonable
    const base = Math.floor((window.innerWidth * window.innerHeight) / 18000);
    NODE_COUNT = Math.max(55, Math.min(140, base));

    nodes = Array.from({ length: NODE_COUNT }, () => {
      const x = rand(0, window.innerWidth);
      const y = rand(0, window.innerHeight);
      return {
        x, y,
        ox: x, oy: y,              // origin (for gentle return)
        vx: rand(-0.35, 0.35),
        vy: rand(-0.35, 0.35),
        r: rand(1.2, 2.1)
      };
    });
  }

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function rgba(c, a) {
    return `rgba(${c.r},${c.g},${c.b},${a})`;
  }

  // Pointer handlers (mouse + touch)
  function setPointerFromEvent(e) {
    if (e.touches && e.touches[0]) {
      pointer.x = e.touches[0].clientX;
      pointer.y = e.touches[0].clientY;
      pointer.active = true;
      return;
    }
    pointer.x = e.clientX;
    pointer.y = e.clientY;
  }

  window.addEventListener("mousemove", (e) => {
    setPointerFromEvent(e);
    pointer.active = true;
  }, { passive: true });

  window.addEventListener("mouseenter", () => { pointer.active = true; }, { passive: true });
  window.addEventListener("mouseleave", () => { pointer.active = false; }, { passive: true });

  window.addEventListener("touchstart", (e) => {
    setPointerFromEvent(e);
    pointer.active = true;
  }, { passive: true });

  window.addEventListener("touchmove", (e) => {
    setPointerFromEvent(e);
    pointer.active = true;
  }, { passive: true });

  window.addEventListener("touchend", () => {
    pointer.active = false;
  }, { passive: true });

  // Resize
  window.addEventListener("resize", () => {
    setCanvasSize();
    buildNodes();
  });

  // Initialize
  setCanvasSize();
  buildNodes();

  function updateNode(n) {
    // Gentle drift
    n.vx += rand(-0.01, 0.01);
    n.vy += rand(-0.01, 0.01);

    // Soft pull back to original position (keeps composition stable)
    const dxo = n.ox - n.x;
    const dyo = n.oy - n.y;
    n.vx += dxo * RETURN_FORCE;
    n.vy += dyo * RETURN_FORCE;

    // Pointer interaction: attract + slight orbit feel
    if (pointer.active) {
      const dxp = pointer.x - n.x;
      const dyp = pointer.y - n.y;
      const dist = Math.hypot(dxp, dyp);

      if (dist < pointer.radius) {
        const safeDist = Math.max(POINTER_MIN_DIST, dist);
        const t = 1 - safeDist / pointer.radius; // 0..1

        // Attraction vector
        const ax = (dxp / safeDist) * (POINTER_FORCE * t);
        const ay = (dyp / safeDist) * (POINTER_FORCE * t);

        // Slight orbit component (perpendicular)
        const ox = -ay * 0.55;
        const oy =  ax * 0.55;

        n.vx += ax + ox;
        n.vy += ay + oy;
      }
    }

    // Friction + speed cap
    n.vx *= FRICTION;
    n.vy *= FRICTION;

    n.vx = clamp(n.vx, -BASE_SPEED, BASE_SPEED);
    n.vy = clamp(n.vy, -BASE_SPEED, BASE_SPEED);

    // Move
    n.x += n.vx;
    n.y += n.vy;

    // Bounce edges
    if (n.x < 0) { n.x = 0; n.vx *= -1; }
    if (n.x > window.innerWidth) { n.x = window.innerWidth; n.vx *= -1; }
    if (n.y < 0) { n.y = 0; n.vy *= -1; }
    if (n.y > window.innerHeight) { n.y = window.innerHeight; n.vy *= -1; }
  }

  function draw() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    // Update nodes
    for (const n of nodes) updateNode(n);

    // Draw connections
    for (let i = 0; i < nodes.length; i++) {
      const a = nodes[i];
      for (let j = i + 1; j < nodes.length; j++) {
        const b = nodes[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const dist = Math.hypot(dx, dy);

        if (dist < MAX_DIST) {
          // base opacity
          let alpha = 1 - dist / MAX_DIST;

          // boost near pointer
          if (pointer.active) {
            const da = Math.hypot(pointer.x - a.x, pointer.y - a.y);
            const db = Math.hypot(pointer.x - b.x, pointer.y - b.y);
            const near = Math.min(da, db);
            if (near < pointer.radius) {
              const t = 1 - near / pointer.radius;
              alpha *= (1 + t * (HOVER_BOOST - 1));
            }
          }

          ctx.strokeStyle = rgba(COLOR_LINE, alpha * 0.55);
          ctx.lineWidth = 0.75;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    // Draw nodes (with glow)
    for (const n of nodes) {
      let glow = 0.22;

      if (pointer.active) {
        const d = Math.hypot(pointer.x - n.x, pointer.y - n.y);
        if (d < pointer.radius) {
          const t = 1 - d / pointer.radius;
          glow = 0.22 + t * 0.55;
        }
      }

      // outer glow
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r + 3, 0, Math.PI * 2);
      ctx.fillStyle = rgba(COLOR_NODE, glow * 0.18);
      ctx.fill();

      // core node
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
      ctx.fillStyle = rgba(COLOR_NODE, 0.95);
      ctx.fill();
    }

    requestAnimationFrame(draw);
  }

  draw();
</script>

</body>
</html>

